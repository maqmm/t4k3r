import asyncio
import random
import json
import os
import re
import itertools

from telethon import TelegramClient, events
from telethon.tl.functions.account import UpdateEmojiStatusRequest, UpdateColorRequest
from telethon.tl.functions.messages import GetStickerSetRequest
from telethon.tl.types import EmojiStatus, InputStickerSetShortName, MessageEntityCustomEmoji, MessageEntityUrl
from telethon import types
from telethon.extensions import markdown
from telethon.errors.rpcerrorlist import DocumentInvalidError

from datetime import datetime
from collections import deque
from itertools import islice

from dotenv import load_dotenv
load_dotenv()
sesion_name = os.getenv('SESSION_NAME')
file_path = os.getenv('EMOJI_FILE_PATH')
api_id = os.getenv('API_ID')
api_hash = os.getenv('API_HASH')

# emojis
e_del_list = '[üö´](emoji/5462882007451185227)'  # –í—Å–µ–≥–æ –∏—Å–∫–ª—é—á–µ–Ω–æ (no)
e_ban = '[üö´](emoji/5454350746407419714)'  # –ë—ã–ª–æ –∏—Å–∫–ª—é—á–µ–Ω–æ & —É–¥–∞–ª—ë–Ω –∏–∑ —Å—Ç–∞—Ç—É—Å–∞ (kick)
e_ban2 = '[üö´](emoji/5463358164705489689)'  # ban
e_delete = '[üòµ](emoji/5463274047771000031)'  # –£–¥–∞–ª–µ–Ω—ã –∏—Å–∫–ª—é—á–µ–Ω–∏—è (frag +1)
e_add = '[‚úÖ](emoji/5462956611033117422)'  # –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ç–∞—Ç—É—Å (save)
e_fix = '[üõ†](emoji/5462921117423384478)'  # FIX
e_l_error = '[üòµ](emoji/5465265370703080100)'
e_r_error = e_fix
e_cleared = '[üòµ](emoji/5226702984204797593)'  # —Å–ø–∏—Å–æ–∫ –∏—Å–∫–ª—é—á–µ–Ω–∏–π –æ—á–∏—â–µ–Ω (wipe)
e_invisible = '[üóø](emoji/5323411714836810037)'
e_omg = '[üòµ](emoji/5454182632797521992)'  # OMG
e_sad = '[üòµ](emoji/5463137996091962323)'  # SAD
e_default = 5337323753858685200  # —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—Ä–∏ –ø—É—Å—Ç–æ–º json (–∫—É–±–∏–∫ 20)

banALL = False
ban_list = []

# message colors
# –Ω–æ–º–µ—Ä —Ä—è–¥–∞ (–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏) - –Ω–æ–º–µ—Ä —Ü–≤–µ—Ç–∞ –≤ —Ä—è–¥—É = id
# 1-1 = 5     2-1 = 12     3-1 = 14
# 1-2 = 3     2-2 = 10     3-2 = 15
# 1-3 = 1     2-3 = 8      3-3 = 16
# 1-4 = 0     2-4 = 7      3-4 = 17
# 1-5 = 2     2-5 = 9      3-5 = 18
# 1-6 = 4     2-6 = 11     3-6 = 19
# 1-7 = 6     2-7 = 13     3-7 = 20
default_message_color_id = 9

# profile colors
# –Ω–æ–º–µ—Ä —Ä—è–¥–∞ (–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏) - –Ω–æ–º–µ—Ä —Ü–≤–µ—Ç–∞ –≤ —Ä—è–¥—É = id
# 1-1 = 5    2-1 = 13
# 1-2 = 3    2-2 = 11
# 1-3 = 1    2-3 = 9
# 1-4 = 0    2-4 = 8
# 1-5 = 2    2-5 = 10
# 1-6 = 4    2-6 = 12
# 1-7 = 6    2-7 = 14
# 1-8 = 7    2-8 = 15
default_profile_color_id = 10

# –º–∞—Å—Å–∏–≤ —Å –ª–æ–≥–∞–º–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —ç–º–æ–≥–∏
logs = {
    'main': deque(maxlen=100),  # –æ—Å–Ω–æ–≤–Ω—ã–µ —ç–º–æ–≥–∏ –ø—Ä–æ—Ñ–∏–ª—è
    'bg': deque(maxlen=100),    # —ç–º–æ–≥–∏ —Ñ–æ–Ω–∞ –ø—Ä–æ—Ñ–∏–ª—è
    'msg': deque(maxlen=100)    # —ç–º–æ–≥–∏ —Ñ–æ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
}


# links - —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–∞–∫ : –º–∞—Å—Å–∏–≤ –∏–∑ –∞–π–¥–∏ —ç–º–æ–¥–∑–∏
# exceptions - —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–∞–∫ : –º–∞—Å—Å–∏–≤ –∏–∑ –∞–π–¥–∏ —ç–º–æ–¥–∑–∏
# message_background_emoji - —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–∞–∫ : –º–∞—Å—Å–∏–≤ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö
clean_json = {"links": {}, "exceptions": [], "message_background_emoji": {}}

client = TelegramClient(sesion_name, api_id, api_hash, system_version="Windows 10", app_version='5.13.1 x64', device_model='MS-7B89', system_lang_code='ru-RU', lang_code='en')


# –æ–±–º–∞–Ω —á—Ç–æ–±—ã –Ω–∞–±—Ä–∞—Ç—å –∫–ª–∞—Å—Å—ã (–¥–ª—è —Ä–∞–±–æ—Ç—ã —ç—Ç–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ [‚úÖ](emoji/5454014806950429357))
class CustomMarkdown:
    @staticmethod
    def parse(text):
        text, entities = markdown.parse(text)
        for i, e in enumerate(entities):
            if isinstance(e, types.MessageEntityTextUrl):
                if e.url == 'spoiler':
                    entities[i] = types.MessageEntitySpoiler(e.offset, e.length)
                elif e.url.startswith('emoji/'):
                    entities[i] = types.MessageEntityCustomEmoji(e.offset, e.length, int(e.url.split('/')[1]))
        return text, entities

    @staticmethod
    def unparse(text, entities):
        for i, e in enumerate(entities or []):
            if isinstance(e, types.MessageEntityCustomEmoji):
                entities[i] = types.MessageEntityTextUrl(e.offset, e.length, f'emoji/{e.document_id}')
            if isinstance(e, types.MessageEntitySpoiler):
                entities[i] = types.MessageEntityTextUrl(e.offset, e.length, 'spoiler')
        return markdown.unparse(text, entities)


client.parse_mode = CustomMarkdown()


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–∞–π–ª–∞
def load_json(file_path):
    if not os.path.exists(file_path):
        with open(file_path, 'w') as json_file:
            json.dump(clean_json, json_file)

    with open(file_path, 'r') as json_file:
        return json.load(json_file)


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ —Ñ–∞–π–ª
def save_json(file_path, data):
    with open(file_path, 'w') as json_file:
        json.dump(data, json_file, separators=(", ", ": "))


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–∞–ø–∏—Å–∏
def add_pack(data, array_name, link_name, values_array):
    if link_name in data[array_name]:
        return False

    data[array_name][link_name] = values_array
    return True


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–ø–∏—Å–∏
def remove_pack(data, array_name, link_name, _):
    if link_name in data[array_name]:
        del data[array_name][link_name]
        return True
    return False


@client.on(events.NewMessage(outgoing=True, pattern=r'(?i)\.(add|del)'))
async def handler_add(event):
    try:
        data = await asyncio.to_thread(load_json, file_path)
        # –µ—Å–ª–∏ –ø—Ä–æ—Å—Ç–æ .del
        if re.match(r'(?i)\.del$', event.message.message):
            exceptions_id = data["exceptions"]
            emoji_chunks = [exceptions_id[i:i + 96] for i in range(0, len(exceptions_id), 96)]  # –†–∞–∑–±–∏–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ 96 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            text = f'{e_del_list}–í—Å–µ–≥–æ –∏—Å–∫–ª—é—á–µ–Ω–æ **{len(exceptions_id)}** —ç–º–æ–¥–∑–∏:'
            await client.edit_message(event.chat_id, event.id, text)
            # –î–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∞–Ω–∫–∞ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            for chunk in emoji_chunks:
                text = ""
                for emoji in chunk:
                    text += f'[üõ†](emoji/{emoji})'
                await client.send_message(event.chat_id, text)
                await asyncio.sleep(random.randint(1, 3))

        # –µ—Å–ª–∏ –µ—Å—Ç—å —ç–º–æ–≥–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏
        elif isinstance(event.entities[0], MessageEntityCustomEmoji):
            document_ids = [entity.document_id for entity in event.entities]
            # (–¥–ª—è .del)
            if re.match(r'(?i)\.del$', event.message.message.split(' ', 1)[0]):
                i = 0
                text2 = ""
                for value in document_ids:
                    if value not in data["exceptions"]:
                        data["exceptions"].append(value)
                        text2 += f'[üö´](emoji/{value})'
                        i += 1

                text1 = f'{e_ban}–ë—ã–ª–æ –∏—Å–∫–ª—é—á–µ–Ω–æ **{i}** —ç–º–æ–¥–∑–∏:\n\n'
                await client.edit_message(event.chat_id, event.id, f'{text1}{text2}')
                save_json(file_path, data)

            # (–¥–ª—è .add)
            elif re.match(r'(?i)\.add$', event.message.message.split(' ', 1)[0]):
                delete_ids = [exceptions for exceptions in data["exceptions"] if exceptions in document_ids]
                data["exceptions"] = [exceptions for exceptions in data["exceptions"] if exceptions not in document_ids]

                text = f'{e_delete}–£–¥–∞–ª–µ–Ω—ã –∏—Å–∫–ª—é—á–µ–Ω–∏—è (**{len(delete_ids)}** —à—Ç):\n\n'
                for emoji in delete_ids:
                    text += f'[üó°](emoji/{emoji})'

                await client.edit_message(event.chat_id, event.id, text)
                save_json(file_path, data)

        # –µ—Å–ª–∏ –µ—Å—Ç—å —Å—Å—ã–ª–∫–∞ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏
        elif isinstance(event.entities[0], MessageEntityUrl):
            command = event.message.message.split(' ', 1)[0]
            url = event.message.message.rsplit(' ', 1)[-1]
            sticker_set_name = url.split('addemoji/')[-1]

            sticker_set = await client(GetStickerSetRequest(InputStickerSetShortName(sticker_set_name), hash=0))
            title = sticker_set.set.title
            count = sticker_set.set.count
            adaptive = sticker_set.set.text_color
            array_name = "links"
            command_text = ".add"  # –Ω–∞ –∫–æ–º–∞–Ω–¥—É del
            bg = " –∏–∑ —Å—Ç–∞—Ç—É—Å–∞"
            just = " –£–ñ–ï "
            save_emoji = e_ban
            add_del = "—É–¥–∞–ª—ë–Ω"

            document_ids = [document.id for document in sticker_set.documents]

            add_or_del = remove_pack
            if re.match(r'(?i)\.add', command):
                add_or_del = add_pack
                save_emoji = e_add
                add_del = "–¥–æ–±–∞–≤–ª–µ–Ω"
                bg = " –≤ —Å—Ç–∞—Ç—É—Å"
                command_text = ".add"  # –Ω–∞ –∫–æ–º–∞–Ω–¥—É add

            if re.match(r'(?i)\.addbg', command):
                if adaptive is False:
                    text = f'{e_fix}[–ù–∞–±–æ—Ä –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ê–î–ê–ü–¢–ò–í–ù–´–ú]({url}){e_fix}'
                    await client.edit_message(event.chat_id, event.id, text, link_preview=False)
                    return
                array_name = "message_background_emoji"
                command_text = ".addbg"  # –Ω–∞ –∫–æ–º–∞–Ω–¥—É addbg
                bg = " –≤ —Ñ–æ–Ω"

            elif re.match(r'(?i)\.delbg', command):
                array_name = "message_background_emoji"
                command_text = ".addbg"  # –Ω–∞ –∫–æ–º–∞–Ω–¥—É delbg
                bg = " –∏–∑ —Ñ–æ–Ω–∞"

            state = add_or_del(data, array_name, url, document_ids)

            if state is True:
                just = " "

            emoji_ids = document_ids[:10]
            emojis = ""

            for emoji_id in emoji_ids:
                emojis += f'[üòµ](emoji/{emoji_id})'
            # text = f'{save_emoji}[–ù–∞–±–æ—Ä{just}{add_del}{bg}]({url}){save_emoji}```{title} ({count} —à—Ç)````{command_text} {url}`'
            text = f'{save_emoji}–ù–∞–±–æ—Ä{just}**{add_del}{bg}**{save_emoji}\n\n{emojis}\n\n[{title} ({count} —à—Ç)]({url})\n\n`{command_text} {url}`'

            await client.edit_message(event.chat_id, event.id, text, link_preview=False)
            save_json(file_path, data)

    except Exception as e:
        text = f'{e_l_error}**–ê–®–ò–ü–ö–ê!**{e_r_error}\n{e}'
        await client.edit_message(event.chat_id, event.id, text)


@client.on(events.NewMessage(outgoing=True, pattern=r'(?i)\.clear'))
async def handler_clear(event):
    data = await asyncio.to_thread(load_json, file_path)

    if re.match(r'(?i)\.clearstatus$', event.message.message):
        data["links"] = clean_json["links"]
        msg = "–°–ø–∏—Å–æ–∫ **—Å—Ç–∞—Ç—É—Å–∞** –æ—á–∏—â–µ–Ω"

    elif re.match(r'(?i)\.clearexc$', event.message.message):
        data["exceptions"] = clean_json["exceptions"]
        msg = "–°–ø–∏—Å–æ–∫ **–∏—Å–∫–ª—é—á–µ–Ω–∏–π** –æ—á–∏—â–µ–Ω"

    elif re.match(r'(?i)\.clearbg$', event.message.message):
        data["message_background_emoji"] = clean_json["message_background_emoji"]
        msg = "–°–ø–∏—Å–æ–∫ **—Ñ–æ–Ω–∞** –æ—á–∏—â–µ–Ω"

    elif re.match(r'(?i)\.clearall$', event.message.message):
        data = clean_json
        msg = "**–í–°–ï** c–ø–∏—Å–∫–∏ –æ—á–∏—â–µ–Ω—ã"

    else:
        await asyncio.sleep(1)
        await client.delete_messages(event.chat_id, [event.id, event.id])
        return

    save_json(file_path, data)
    text = f'{e_cleared}{msg}{e_cleared}'
    await client.edit_message(event.chat_id, event.id, text)


@client.on(events.NewMessage(outgoing=True, pattern=r'(?i)^\.ban(?:\s+(\d+)|(?:\s+@(\w+))|all)$'))
async def handler_bans(event):
    is_banall = event.text.lower().endswith('all')  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ .banall
    if is_banall:
        if banALL:
            await client.edit_message(event.chat_id, event.id, f"{e_ban2} **–í—Å–µ** –∑–∞–ø—Ä–æ—Å—ã —É–∂–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã")
            return
        await ban_function("all", event.chat_id, event.id)
    else:
        username = event.pattern_match.group(2)   # –Æ–∑–µ—Ä–Ω–µ–π–º (–µ—Å–ª–∏ –µ—Å—Ç—å @)
        try:
            if username:
                user = await client.get_entity(username)
            else:
                user_id = event.pattern_match.group(1)  # –ß–∏—Å–ª–æ (–µ—Å–ª–∏ –µ—Å—Ç—å)
                user = await client.get_entity(int(user_id))
        except Exception as e:
            await client.edit_message(event.chat_id, event.id, e)
        if user.id in ban_list:
            await client.edit_message(event.chat_id, event.id, f"{e_ban2} –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å **–£–ñ–ï** –≤ –±–∞–Ω–µ")
            return
        await ban_function("list", event.chat_id, event.id, user=user)


async def ban_function(type, chat_id, msg_id, user=None):
    global banALL, ban_list
    time = random.randint(900, 1800)
    if type == "all":
        banALL = True
        text = f"{e_ban2} **–í—Å–µ** –∑–∞–ø—Ä–æ—Å—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ {time} —Å"
        await client.edit_message(chat_id, msg_id, text)
        await asyncio.sleep(time)
        banALL = False

    if type == "list":
        ban_list.append(user.id)
        last_name = f" {user.last_name}" if user.last_name else ""
        username = f" @{user.username}" if user.username else ""
        name = user.first_name + last_name + username
        text = f"{e_ban2} –ó–∞–ø—Ä–æ—Å—ã **{name}** –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ {time} —Å"
        await client.edit_message(chat_id, msg_id, text)
        await asyncio.sleep(time)
        ban_list.remove(user.id)


@client.on(events.NewMessage(pattern=r'(?i)^\.(logs|logsbg|logsmsg)(?:\s+(\d+)|\s+@(\w+)(?:\s+(\d+))?)?$'))
async def handler_logs(event):
    if event.from_id is None:
        pass
    else:
        if banALL or event.from_id.user_id in ban_list:
            return

    me = await client.get_me()
    sender = await event.get_sender()
    # .logs @username 10
    # command - .logs
    # num1 - —á–∏—Å–ª–æ –ø–æ—Å–ª–µ logs –µ—Å–ª–∏ –±–µ–∑ @username
    # username_msg - @username
    # num2 - 10
    command = event.pattern_match.group(1)
    num1 = event.pattern_match.group(2)
    username_msg = event.pattern_match.group(3)
    num2 = event.pattern_match.group(4)

    # –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –æ—Ç —Å–µ–±—è –∏ –µ—Å—Ç—å @username(—á—å–∏ –ª–æ–≥–∏ —Ö–æ—Ç—è—Ç) –∏ (—á–∏—Å–ª–æ) –∏ —á–µ–ª–æ–≤–µ–∫ –≤ –∫–æ–Ω—Ç–∞–∫—Ç–∞—Ö
    if event.out is False and username_msg == me.username and sender.contact:
        if num2 is None:
            count = 5
        else:
            count = int(num2)
        type = "send"

    # –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç —Å–µ–±—è –∏ –Ω–µ—Ç @username
    elif event.out is True and username_msg is None:
        if num1 is None:
            count = 5
        else:
            count = int(num1)
        type = "edit"

    else:
        return

    if not 0 < count < 101:
        count = 5

    # —Ñ–∏–ª—å—Ç—Ä—ã –Ω–∞ —Ç–∏–ø—ã –ª–æ–≥–æ–≤
    if command == ".logsbg":
        last_logs = islice(logs["bg"], max(0, len(logs["bg"]) - count), None)
        if len(logs["bg"]) < count:
            count = len(logs["bg"])
        text = f"{count} —ç–º–æ–¥–∂–∏ **—Ñ–æ–Ω–∞ –ø—Ä–æ—Ñ–∏–ª—è**:\n"

    elif command == "logsmsg":
        last_logs = islice(logs["msg"], max(0, len(logs["msg"]) - count), None)
        if len(logs["msg"]) < count:
            count = len(logs["msg"])
        text = f"{count} —ç–º–æ–¥–∂–∏ **—Ñ–æ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–π**:\n"
    else:
        last_logs = islice(logs["main"], max(0, len(logs["main"]) - count), None)
        if len(logs["main"]) < count:
            count = len(logs["main"])
        text = f"{count} —ç–º–æ–¥–∂–∏ **–ø—Ä–æ—Ñ–∏–ª—è**:\n"

    text += '\n'.join(map(str, last_logs))

    if type == "edit":
        await client.edit_message(event.chat_id, event.id, text)
    elif type == "send":
        await client.send_message(event.chat_id, text)


# —É–∑–Ω–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–º–æ–≥–∏ –∏ –Ω–∞–±–æ—Ä–æ–≤ –≤ data.json
async def count_emoji():
    data = await asyncio.to_thread(load_json, file_path)
    array_names = ["links", "message_background_emoji", "exceptions"]
    numbers = []

    for array_name in array_names:
        total_count = 0
        total_packs = len(data[array_name])
        if not array_name == "exceptions":
            for values in data[array_name].values():
                total_count += len(values)
            numbers.append(total_count)
            numbers.append(total_packs)
        else:
            numbers.append(total_packs)
    return numbers


@client.on(events.NewMessage(outgoing=True, pattern=r'(?i)\.backup'))
async def handler_backup(event):
    counts = await count_emoji()
    date = datetime.now().strftime("%d.%m.%Y %H:%M:%S")
    text = f"""
<em>{date}</em>

<b>–í —Å—Ç–∞—Ç—É—Å–µ</b>:
<b>{counts[0]}</b> —ç–º–æ–¥–∑–∏ (<b>{counts[1]}</b> packs)

<b>–í —Ñ–æ–Ω–µ</b>:
<b>{counts[2]}</b> —ç–º–æ–¥–∑–∏ (<b>{counts[3]}</b> packs)

<b>–ò—Å–∫–ª—é—á–µ–Ω–æ</b>:
<b>{counts[4]}</b> —ç–º–æ–¥–∑–∏
"""
    await client.edit_message(event.chat_id, event.id, text, file=file_path, parse_mode='html')


@client.on(events.NewMessage(outgoing=True, pattern=r'(?i)\.info'))
async def handler_commands(event):
    text = f'''
<code>.add </code><em>[—Å—Å—ã–ª–∫–∞ –Ω–∞ –Ω–∞–±–æ—Ä]</em> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –Ω–∞–±–æ—Ä –≤ —Å—Ç–∞—Ç—É—Å –ø—Ä–æ—Ñ–∏–ª—è
<code>.add </code><em>[—ç–º–æ–¥–∑–∏]</em> ‚Äî —É–¥–∞–ª–∏—Ç—å —ç–º–æ–¥–∑–∏ –∏–∑ –∏—Å–∫–ª—é—á–µ–Ω–∏–π
<code>.addbg </code><em>[—Å—Å—ã–ª–∫–∞ –Ω–∞ –Ω–∞–±–æ—Ä]</em> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –Ω–∞–±–æ—Ä –≤ —Ñ–æ–Ω –ø—Ä–æ—Ñ–∏–ª—è –∏ —Å–æ–æ–±—â–µ–Ω–∏–π

<code>.del</code> ‚Äî —Å–ø–∏—Å–æ–∫ –æ–±—â–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π
<code>.del </code><em>[—Å—Å—ã–ª–∫–∞ –Ω–∞ –Ω–∞–±–æ—Ä]</em> ‚Äî —É–¥–∞–ª–∏—Ç—å –Ω–∞–±–æ—Ä –∏–∑ —Å—Ç–∞—Ç—É—Å–∞ –ø—Ä–æ—Ñ–∏–ª—è
<code>.del </code><em>[—ç–º–æ–¥–∑–∏]</em> ‚Äî –∏—Å–∫–ª—é—á–∏—Ç—å —ç–º–æ–¥–∑–∏
<code>.delbg </code><em>[—Å—Å—ã–ª–∫–∞ –Ω–∞ –Ω–∞–±–æ—Ä]</em> ‚Äî —É–¥–∞–ª–∏—Ç—å –Ω–∞–±–æ—Ä –∏–∑ —Ñ–æ–Ω–∞ –ø—Ä–æ—Ñ–∏–ª—è –∏ —Å–æ–æ–±—â–µ–Ω–∏–π

<code>.all</code> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –Ω–∞–±–æ—Ä—ã —Å—Ç–∞—Ç—É—Å–∞ –ø—Ä–æ—Ñ–∏–ª—è
<code>.allbg</code> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –Ω–∞–±–æ—Ä—ã —Ñ–æ–Ω–∞ –ø—Ä–æ—Ñ–∏–ª—è –∏ —Å–æ–æ–±—â–µ–Ω–∏–π

<code>.clearstatus</code> ‚Äî —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –Ω–∞–±–æ—Ä—ã –∏–∑ —Å—Ç–∞—Ç—É—Å–∞
<code>.clearexc</code> ‚Äî —É–¥–∞–ª–∏—Ç—å –≤—Å–µ —ç–º–æ–¥–∑–∏-–∏—Å–∫–ª—é—á–µ–Ω–∏—è
<code>.clearbg</code> ‚Äî —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –Ω–∞–±–æ—Ä—ã –∏–∑ —Ñ–æ–Ω–∞
<code>.clearall</code> ‚Äî —É–¥–∞–ª–∏—Ç—å –í–°–ï –Ω–∞–±–æ—Ä—ã —ç–º–æ–¥–∑–∏

<code>.backup</code> ‚Äî –≤—ã–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª —Å–æ –≤—Å–µ–º–∏ –Ω–∞–±–æ—Ä–∞–º–∏

<code>.logs </code><em>[N]</em> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N (–¥–æ 100) —ç–º–æ–¥–∑–∏ –ø—Ä–æ—Ñ–∏–ª—è
<code>.logsmsg </code><em>[N]</em> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N (–¥–æ 100) —ç–º–æ–¥–∑–∏ —Ñ–æ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
<code>.logsbg </code><em>[N]</em> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N (–¥–æ 100) —ç–º–æ–¥–∑–∏ —Ñ–æ–Ω–∞ –ø—Ä–æ—Ñ–∏–ª—è

<code>.logs </code><em>@username [N]</em> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N (–¥–æ 100) —ç–º–æ–¥–∑–∏ –ø—Ä–æ—Ñ–∏–ª—è –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
<code>.logsmsg </code><em>@username [N]</em> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N (–¥–æ 100) —ç–º–æ–¥–∑–∏ —Ñ–æ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
<code>.logsbg </code><em>@username [N]</em> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N (–¥–æ 100) —ç–º–æ–¥–∑–∏ —Ñ–æ–Ω–∞ –ø—Ä–æ—Ñ–∏–ª—è –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

<code>.ban </code><em>@username</em> ‚Äî –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å –≤–∞—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —ç–º–æ–¥–∑–∏
<code>.banall</code> ‚Äî –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å –í–°–ï–ú –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å –≤–∞—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —ç–º–æ–¥–∑–∏

<code>.üóø</code> ‚Äî —á–µ—Ä—Ç–∏–ª–∞
    '''
    await client.edit_message(event.chat_id, event.id, text, parse_mode='html')


@client.on(events.NewMessage(outgoing=True, pattern=r'(?i)\.üóø'))
async def handler_stone(event):
    text1 = '''
üü´üü´üü´üü´üü´üü•üü•üü´
üü´üü•üü•üü´üü´üü´üü´üü´
üü´üü´üü´üü´üü´üü´üü´üü´
üü´üü´üü•üü´üü´üü•üü´üü´
üü´üü´üü•üü´üü´üü•üü´üü´
üü´üü´üü´üü´üü´üü´üü´üü´
üü´üü•üü•üü•üü•üü•üü•üü´'''

    text2 = '''
üü´üü•üü•üü´üü´üü´üü´üü´
üü´üü´üü´üü´üü´üü•üü•üü´
üü´üü´üü´üü´üü´üü´üü´üü´
üü´üü´üü•üü´üü´üü•üü´üü´
üü´üü´üü•üü´üü´üü•üü´üü´
üü´üü´üü´üü´üü´üü´üü´üü´
üü´üü•üü•üü•üü•üü•üü•üü´'''
    text1 = text1.replace('üü´', e_invisible)
    text2 = text2.replace('üü´', e_invisible)
    text = [text1, text2, text1, text2, text1]

    stone = [5796270094954794959, 5796528609036341197, 5796151871685006544, 5794130221988844552, 5796154775082896990, 5794315425273614049, 5794405619586829877, 5796637413442850695, 5796181768952352381, 5794036222334603423, 5796662569066303188, 5794254763155525471, 5796149316179463874, 5796173161837891411, 5796578963232920077, 5794204000937055520, 5796658467372536325, 5796656182449933846, 5793905539364687563, 5796303239217418190, 5794380773201022246, 5794051787296084051, 5796141404849705080, 5794038760660274509, 5794180571890455776, 5794120871845040459, 5796694424838737320, 5796382747652001425, 5794287142913969546, 5794135015172345363, 5794109782239482498, 5796503277319228628, 5796582124328849695, 5794163374841401278, 5794129105297348415, 5796334970435800723, 5796211743529111404, 5796636618873900998, 5794401062626529888, 5796615676613365556, 5213305508034783384, 5172645971766543291, 5208878706717636743, 5208601921845208724, 5192683149548605430]

    random.shuffle(stone)
    stone = stone[:4]
    stone.append(5442983582882601962)

    for index, emoji in enumerate(text, start=0):
        message = text[index].replace('üü•', f'[üóø](emoji/{stone[index]})')
        await client.edit_message(event.chat_id, event.id, message)
        await asyncio.sleep(1)


@client.on(events.NewMessage(outgoing=True, pattern=r'(?i)\.all'))
async def handler_all(event):
    data = await asyncio.to_thread(load_json, file_path)

    if re.match(r'(?i)\.allbg', event.message.message.split(' ', 1)[0]):
        array_name = "message_background_emoji"
        dot_add_del = ".delbg"
        status_or_bg = " –¥–ª—è —Ñ–æ–Ω–∞"
    else:
        array_name = "links"
        dot_add_del = ".del"
        status_or_bg = " –≤ —Å—Ç–∞—Ç—É—Å–µ"

    link_names = list(data[array_name].keys())

    total_count = 0
    total_packs = len(data[array_name])  # –≤—ã–≤–æ–¥ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–∞–±–æ—Ä–æ–≤ –≤ .all
    for values in data[array_name].values():
        total_count += len(values)

    if total_count == 0:
        text = f'{e_sad}–í—Å–µ–≥–æ **{total_count}** —ç–º–æ–¥–∂–∏**{status_or_bg}**{e_sad}'
        await client.edit_message(event.chat_id, event.id, text)
        return

    text = f'{e_omg}–í—Å–µ–≥–æ **{total_count}** —ç–º–æ–¥–∂–∏**{status_or_bg}**{e_omg}\n{e_invisible}From **{total_packs}** packs\n\n'  # –≤—ã–≤–æ–¥ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–∞–±–æ—Ä–æ–≤ –≤ .all

    for index, url in enumerate(link_names, start=1):
        emoji_ids = data[array_name][url][:5]
        emojis = ""

        for emoji_id in emoji_ids:
            emojis += f'[üòµ](emoji/{emoji_id})'

        text += f'{index}. {emojis}\n{url}\n`{dot_add_del} {url}`\n\n'

        if index % 19 == 0:
            if index == 19:  # –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                await client.edit_message(event.chat_id, event.id, text, link_preview=False)
            else:
                await client.send_message(event.chat_id, text, link_preview=False)
            text = ""
            await asyncio.sleep(random.randint(1, 3))

    if text:
        if index < 19:
            await client.edit_message(event.chat_id, event.id, text, link_preview=False)
        else:
            await client.send_message(event.chat_id, text, link_preview=False)


async def get_random_ids(data, array_name, max_len=27000):  # ~–Ω–µ–¥–µ–ª—è –Ω–µ–ø–æ–≤—Ç–æ—Ä–∞—è—â–∏—Ö—Å—è
    exceptions = set(data['exceptions'])
    all_items = itertools.chain.from_iterable(
        (num for num in array if num not in exceptions)
        for array in data[array_name].values())

    all_items = list(all_items)  # Materialize only once
    if len(all_items) <= max_len:
        random.shuffle(all_items)
        return all_items

    return random.sample(all_items, max_len)


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥–≥–æ–Ω–∫–∏ –º–∞—Å—Å–∏–≤–∞
async def generate_array(length, num):
    arr2 = list(range(num))  # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Ç–æ—Ä–æ–π –º–∞—Å—Å–∏–≤ –æ—Ç 0 –¥–æ num-1
    result = []
    while len(result) < length:
        result.extend(random.sample(arr2, len(arr2)))  # –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã arr2 –≤ —Å–ª—É—á–∞–π–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    return result[:length]  # –û–±—Ä–µ–∑–∞–µ–º –ª–∏—à–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã


# —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ json –Ω–∞–±–æ—Ä–æ–≤ –∫–æ—Ç–æ—Ä—ã—Ö –±–æ–ª—å—à–µ –Ω–µ—Ç (–≤–ª–∞–¥–µ–ª–µ—Ü —É–¥–∞–ª–∏–ª)
async def remove_deleted_packs(emoji_id, array_name):
    data = await asyncio.to_thread(load_json, file_path)
    for url, ids in data[array_name].items():
        if emoji_id in ids:
            remove_pack(data, array_name, url, None)
            save_json(file_path, data)
            for log in logs.values():
                log.append(f"–£–¥–∞–ª—ë–Ω –Ω–∞–±–æ—Ä: {url}")
            print(f"–£–¥–∞–ª—ë–Ω –Ω–∞–±–æ—Ä: {url}")
            break


# –ø—Ä–æ—Ñ–∏–ª—å —ç–º–æ–∑–¥–∏
async def change_status_emoji():
    array_name_in_json = "links"
    while True:
        try:
            data = await asyncio.to_thread(load_json, file_path)

            random_elements = await get_random_ids(data, array_name_in_json)
            if not random_elements:
                random_elements = [e_default]

            for emoji_id in random_elements:
                time_sleep = random.randint(15, 30)  # –≤—Ä–µ–º—è —Å–º–µ–Ω—ã —ç–º–æ–≥–∏ –≤ –ø—Ä–æ—Ñ–∏–ª–µ
                if random_elements == [e_default]:
                    time_sleep = random.randint(55, 75)

                time = datetime.now().strftime("%H:%M:%S")
                status = EmojiStatus(emoji_id)
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
                await client(UpdateEmojiStatusRequest(status))
                logs["main"].append(f"[üóø](emoji/{emoji_id}) ‚Äì {time}")
                # –ñ–¥–µ–º 15-30 —Å–µ–∫—É–Ω–¥
                await asyncio.sleep(time_sleep)

        except DocumentInvalidError as e:
            print(datetime.now(), e)
            await remove_deleted_packs(emoji_id, array_name_in_json)
            await asyncio.sleep(5)
        except Exception as e:
            print(datetime.now(), e)
            await asyncio.sleep(300)


# –ø—Ä–æ—Ñ–∏–ª—å —Ñ–æ–Ω —ç–º–æ–∑–¥–∏ –∏ —Ü–≤–µ—Ç
async def change_profile_background_emoji_colors():
    array_name_in_json = "message_background_emoji"
    await asyncio.sleep(random.randint(2, 4))
    while True:
        try:
            data = await asyncio.to_thread(load_json, file_path)

            random_elements = await get_random_ids(data, array_name_in_json)
            colors_ids = await generate_array(len(random_elements), 16)
            if not random_elements:
                random_elements = [e_default]  # –∫—É–±–∏–∫ 20
                colors_ids = [default_profile_color_id]

            for index, emoji_id in enumerate(random_elements, start=0):
                time = datetime.now().strftime("%H:%M:%S")
                await client(UpdateColorRequest(
                    for_profile=True,
                    color=colors_ids[index],
                    background_emoji_id=emoji_id))
                logs["bg"].append(f"[üóø](emoji/{emoji_id}) ‚Äì {time}")
                await asyncio.sleep(random.randint(300, 600))  # –≤—Ä–µ–º—è —Å–º–µ–Ω—ã –ø—Ä–æ—Ñ–∏–ª—è —Ñ–æ–Ω–∞ —ç–º–æ–∑–¥–∏ –∏ —Ü–≤–µ—Ç–∞

        except DocumentInvalidError as e:
            print(datetime.now(), e)
            await remove_deleted_packs(emoji_id, array_name_in_json)
            await asyncio.sleep(5)
        except Exception as e:
            print(datetime.now(), e)
            await asyncio.sleep(300)


# —Å–æ–æ–±—â–µ–Ω–∏—è —Ñ–æ–Ω –∏ —ç–º–æ–≥–∏
async def change_message_colors_and_emoji():
    array_name_in_json = "message_background_emoji"
    await asyncio.sleep(random.randint(3, 9))
    while True:
        try:
            data = await asyncio.to_thread(load_json, file_path)

            random_elements = await get_random_ids(data, "message_background_emoji")
            colors_ids = await generate_array(len(random_elements), 21)
            if not random_elements:
                random_elements = [e_default]
                colors_ids = [default_message_color_id]

            for index, emoji_id in enumerate(random_elements, start=0):
                time = datetime.now().strftime("%H:%M:%S")
                await client(UpdateColorRequest(
                    for_profile=None,
                    color=colors_ids[index],
                    background_emoji_id=emoji_id))
                logs["msg"].append(f"[üóø](emoji/{emoji_id}) ‚Äì {time}")
                await asyncio.sleep(random.randint(100, 150))  # –≤—Ä–µ–º—è —Å–º–µ–Ω—ã —Ñ–æ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–π

        except DocumentInvalidError as e:
            print(datetime.now(), e)
            await remove_deleted_packs(emoji_id, array_name_in_json)
            await asyncio.sleep(5)
        except Exception as e:
            print(datetime.now(), e)
            await asyncio.sleep(300)


async def main():
    await client.start()
    asyncio.create_task(change_status_emoji())
    asyncio.create_task(change_profile_background_emoji_colors())
    asyncio.create_task(change_message_colors_and_emoji())

    await client.run_until_disconnected()


client.loop.run_until_complete(main())
